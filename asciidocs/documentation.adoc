= Dokumentation

== Websockets

=== Umsetzung im Mikroprojekt
Sind in meinem Projekt als ChatSocket eingebaut.
Dafür wurde tutorial von der Quarkus.io Website verwendet.
Idee liegt darin, dass Personen fragen wegen der Tanztermine, Tanzkurse, ... stellen können.

=== Was sind Websockets
* Eine dauerhafte Verbindung zwischen Server und Client
* Man kann mit http Daten vom Server zum Client schicken

== GraphQL

=== Umsetzung im Übungsrepository
https://github.com/2122-4ahif-nvs/04-lab-graphql-HautzmayerSheila

=== Umsetzung im Mikroprojekt
<1> @GraphQLApi muss über der Klasse hinzugefügt werden.
<2> Bei der findAll() Methode wird @Query(...) hinzugefügt um später darauf zugreifen zu können.

[source, java]
----
@GraphQLApi <1>
@Path("/Person")
public class PersonResource {
    @ConfigProperty(name = "greeting", defaultValue = "hi")
    String greeting;

    @Inject
    Logger logger;

    @Inject
    PersonRepository personRepository;

    @Inject
    CourseRepository courseRepository;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Query("allPeople") <2>
    public List<Person> findAll() {
        return personRepository.findAll();
    }

----
Aufruf findet dann auf dem GraphQL Server mit folgendem statt.

[source,java]
----
query allPeople {
allPeople {
firstName,
lastName
}
}

----

=== Was ist GraphQL
Es ist eine Abfragesprache. Man erhält nur die Daten, welche man wirklich braucht und möchte.
Durch GraphQL werden APIs schneller und auch flexibler.


== Validation
https://github.com/2122-4ahif-nvs/05-validation-qute-HautzmayerSheila

=== Umsetzung im Mikroprojekt

==== Validierung in Klasse Course

<1> Validierung über das zu validierende Feld schreiben

[source, java]
----

@Entity
public class Course {
@Id @GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
private String name;

    @NotBlank(message="Name must not be blank") <1>
    private String name;

    @Min(message="Course has too less people", value=1) <1>
    private int maxNumberOfPeople;
    @NotBlank(message="Description must not be blank") <1>
    private String description;

----

==== Validierung beim Endpoint

<1> Klasse Result hinzufügen
<2> @Valid wird bei der Parametergabe verwendet

[source, java]
----
@Path("/end-point-method-validation")
@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Result tryMeEndPointMethodValidation(@Valid Course course) { <2>
return new Result("Course is valid! It was validated by end point method validation.");
}

public static class Result {  <1>

        private String message;
        private boolean success;

        Result(String message) {
            this.success = true;
            this.message = message;
        }

        Result(Set<? extends ConstraintViolation<?>> violations) {
            this.success = false;
            this.message = violations.stream()
                    .map(cv -> cv.getMessage())
                    .collect(Collectors.joining(", "));
        }

        public String getMessage() {
            return message;
        }

        public boolean isSuccess() {
            return success;
        }

    }
----

==== Validierung im Repository

<1> Aufruf der Methode im Repo.
<2> @Valid Annotation direkt in der Methode im Repo hinzufügen

[source, java]
----
@Path("/repo-method-validation")
@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Result tryMeServiceMethodValidation(Course course) {
try {
courseRepository.validateCourse(course); <1>
return new Result("Course is valid! It was validated by service method validation.");
} catch (ConstraintViolationException e) {
return new Result(e.getConstraintViolations());
}
}
----

[source,java]
----
public void addCourse(@Valid Course course) { <2>
this.save(course);
}
----

=== Was ist Validation

Durch Validation werden bestimmte Regeln befolgt. Beispielsweise ob ein Feld einer bestimmten Größe haben oder nicht leer sein dürfen.

== Qute


=== Was ist Qute
Es wird eine Art von FrontEnd erstellt.
Man kann zur Laufzeit den Aufbau von Objekten sehen.
Es wird die reflection durch die verringerung von ger Größe von native images minimiert.

=== Umsetzung im ÜbungsRepository
https://github.com/2122-4ahif-nvs/05-validation-qute-HautzmayerSheila

=== Umsetzung im Mikroprojekt

<1> Simples Template im Pfad /src/main/resources/templates/ItemResource/hello.txt

[source,text]
----
Welcome to the dance studio {name}!
----


<1> Eine HelloResource ist geadded worden.
<2> Template wird erzeugt
<3> Neue Template Instanz wird zurückgegeben.

[source,java]
----
@Path("hello")
public class HelloResource { <1>

    @CheckedTemplate
    public static class Templates { <2>
        public static native TemplateInstance hello(String name);
    }

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public TemplateInstance get(@QueryParam("name") String name) {
        return Templates.hello(name); <3>
    }
}

----

== GRPC

=== Was ist GRPC
